PVMTestSuite DEFINITIONS ::= BEGIN

-- a 64-bit signed integer
I64 ::= INTEGER(-9223372036854775808..9223372036854775807)

-- a 64-bit unsigned integer
U64 ::= INTEGER(0..18446744073709551615)

-- a 32-bit unsigned integer
U32 ::= INTEGER(0..4294967295)

-- an 8-bit unsigned integer (a byte)
U8 ::= INTEGER(0..255)

-- a register number (0-12)
Reg ::= INTEGER(0..12)

-- a blob of bytes at a given memory address
MemoryChunk ::= SEQUENCE {
    address U32,
    contents SEQUENCE OF U8
}

-- start or resume the execution of the program
RunStep ::= SEQUENCE {
}

-- verify the current state of the VM
AssertStep ::= SEQUENCE {
    -- (the "ζ" from the paper)
    -- the expected status code of the last interruption
    status ENUMERATED {
        -- the execution ended with a panic (the `trap` instruction was executed, the execution went "out of bounds", an invalid jump was made, or an invalid instruction was executed)
        panic,

        -- the execution finished gracefully (a dynamic jump to address `0xffff0000` was made)
        halt,

        -- the execution was interrupted with a page fault
        page-fault,

        -- we've ran out of gas
        out-of-gas,

        -- a hostcall was triggered
        ecalli
    },

    -- (the "ω′" from the paper)
    -- the expected values of each of the 13 registers
    regs SEQUENCE (SIZE(13..13)) OF U64 OPTIONAL,

    -- (the "ı′" from the paper)
    -- the value of the program counter
    pc U32 OPTIONAL,

    -- (part of the "µ′" from the paper)
    -- a list of memory regions and their expected contents
    memory SEQUENCE OF MemoryChunk OPTIONAL,

    -- (the "ξ′" from the paper)
    -- the amount of gas remaining after the interruption
    gas I64 OPTIONAL,

    -- the address of a page fault (only if the program was interrupted with a page fault)
    page-fault-address U32 OPTIONAL,

    -- the hostcall number (only if the program was interrupted with an ecalli instruction)
    hostcall U32 OPTIONAL
}

-- map one or more pages
MapStep ::= SEQUENCE {
    -- a page-aligned address of the memory region to be mapped
    address U32,

    -- the length of the memory to be mapped, in bytes (but always a multiple of the page size)
    length U32,

    -- whether the mapped region of memory should be writable by the guest program
    is-writable BOOLEAN
}

-- write into the guest's memory
WriteStep ::= SEQUENCE {
    -- the address of where to write
    address U32,

    -- the raw bytes of what to write
    contents SEQUENCE OF U8
}

-- set a register to a given value
SetRegStep ::= SEQUENCE {
    reg Reg,
    value U64
}

Step ::= CHOICE {
    run RunStep,
    assert AssertStep,
    map MapStep,
    write WriteStep,
    set-reg SetRegStep
}

Testcase ::= SEQUENCE {
    -- a unique identifier for the test
    name UTF8String,

    -- (the "ı" from the paper)
    -- the initial program counter from which to start the execution
    initial-pc U32,

    -- (the "ξ" from the paper)
    -- the initial amount of gas
    initial-gas I64,

    -- (the bold "p" from the paper)
    -- the program blob to be executed as part of the test
    program SEQUENCE OF U8,

    -- block gas costs, for each basic block in the program
    block-gas-costs SEQUENCE OF SEQUENCE {
        pc INTEGER,
        cost INTEGER
    },

    -- a list of steps to execute the test
    steps SEQUENCE OF Step
}

END
